package kotlincode.chapter3

/**
 * Вызывая функцию создания списка, вы можете передать ей любое количество аргументов:
 */
val list = listOf(1, 2, 3, 4, 5)

/**
 * Синтаксис вызова функций в Kotlin и Java также отличается способом передачи аргументов, уже упакованных в массив.
 * В Java массив передается непосредственно, a Kotlin требует явно распаковать массив, чтобы каждый элемент стал
 * отдельным аргументом вызываемой функции. Эта операция называется вызовом с оператором распаковки (spread operator),
 * а на практике это просто символ * перед соответствующим аргументом:
 */
fun arrayUnpacking(args: Array<String>) {
    val list = listOf("args: ", *args)      // оператор * распаковывает содержимое массива
    println(list)
}

/**
 * Ключевое слово to в этой строке - не встроенная конструкция, а специальная форма вызова метода, называемая инфиксным вызовом.
 * 1.to("one") - вызов функции to обычным способом
 * 1 to "one" - вызов функции to с использованием инфиксной нотации
 */
val map = mapOf(1 to "one", 7 to "seven", 53 to "fifty-three")

/**
 * Инфиксную форму вызова можно применять к обычным методам и к функциям-расширениям, имеющим один обязательный параметр.
 * Чтобы разрешить вызовы функции в инфиксной нотации, в её объявление нужно добавить модификатор infix:
 */
infix fun Int.plus(that: Int): Int {
    return this + that
}

/**
 * Обратите внимание, что значениями объекта Pair можно инициализировать сразу две переменные.
 * Это называется мультидекларацией (destructuring declaration).
 */
fun iterateAndPrint(list: List<Int>) {
    for ((index, element) in list.withIndex()) {
        println("$index: $element")
    }
}
