package chapter7

import java.math.BigDecimal

/**
 * Перегрузка бинарных арифметических операций
 */
data class Point(val x: Int, val y: Int) {
    operator fun plus(other: Point): Point {        // Определение функции с именем «plus», реализующей оператор
        return Point(x + other.x, y + other.y)      // Складывает координаты и возвращает новую точку
    }
}

fun testPointPlusOperator() {
    val p1 = Point(10, 20)
    val p2 = Point(30, 40)
    println(p1 + p2)        // Вызов функции «plus» путем использования оператора +
}

/**
 * Объявить оператор можно не только как функцию-член, но также как функцию-расширение.
 */
operator fun Point.plus(other: Point): Point {
    return Point(x + other.x, y + other.y)
}

/**
 * Бинарные арифметические операторы, доступные для перегрузки
 *
 *  Выражение       Имя функции
 *    а * b            times
 *    a / b             div
 *    a % b             mod
 *    a + b            plus
 *    a - b            minus
 */

/**
 * Определяя оператор, необязательно использовать одинаковые типы для операндов. Например, давайте определим оператор,
 * позволяющий масштабировать точку в определенное число раз. Он может пригодиться для представления точки в разных
 * системах координат.
 */
operator fun Point.times(scale: Double): Point {
    return Point((x * scale).toInt(), (y * scale).toInt())
}

fun testPointTimesOperator() {
    val p = Point(10, 20)
    println(p * 1.5)
}

/**
 * Обратите внимание, что операторы в Kotlin не поддерживают коммутативность (перемену операндов местами) по умолчанию.
 * Если необходимо дать пользователям возможность использовать выражения вида 1.5 * р в дополнение к р * 1.5,
 * следует определить отдельный оператор: operator fun Double.times(p: Point): Point.
 */

/**
 * Тип значения, возвращаемого функцией-оператором, также может отличаться от типов операндов. Например, можно
 * определить оператор, создающий строку путем повторения заданного символа указанное число раз.
 */
operator fun Char.times(count: Int): String {
    return toString().repeat(count)
}

fun testCharTimes() {
    println('a' * 3)
}

/**
 * Обычно, когда определяется оператор plus, Kotlin начинает поддерживать не только операцию +, но и +=. Операторы +=,
 * -= и другие называют составными операторами присваивания. Например:
 */
fun testCompositeOperators() {
    var point = Point(1, 2)
    point += Point(3, 4)
    println(point)
}

/**
 * В некоторых случаях имеет смысл определить операцию +=, которая могла бы изменить объект, на который ссылается
 * переменная, участвующая в операции, а не менять переменную так, чтобы она ссылалась на другой объект. Один из таких
 * случаев - добавление нового элемента в изменяемую коллекцию:
 */
fun testMutableCollectionCompositeOperator() {
    var numbers = arrayListOf(1, 2, 4)
    numbers += 42       // в коллекцию добавится новый элемент
    println(numbers)

    val list = arrayListOf(1, 2)
    list += 3       // возвращает копию исходной коллекции с модификацией
    val newList = list + listOf(4, 5)   // возвращает новый список, содержащий все элементы
    println(list)
    println(newList)
}

/**
 * Если определить функцию с именем plusAssign, возвращающую значение типа Unit, Kotlin будет вызывать её,
 * встретив оператор +=. Другие составные бинарные операторы выглядят аналогично: minusAssign, timesAssign и т. д.
 */

/**
 * Процедура перегрузки унарного оператора ничем не отличается от описанной выше: объявляется функция
 * (член или расширение) с предопределенным именем, которая затем отмечается модификатором operator.
 * Рассмотрим это на примере.
 */
operator fun Point.unaryMinus(): Point {     // функция, реализующая унарный минус, не имеет параметров
    return Point(-x, -y)        // меняет знак координат точки и возвращает их
}

fun testUnaryMinusOperator() {
    val point = Point(10, 20)
    println(-point)
}

/**
 * Унарные арифметические операторы, доступные для перегрузки
 *
 *  Выражение       Имя функции
 *     +a            unaryPlus
 *     -a            unaryMinus
 *     !a               not
 *  ++a, a++            inc
 *  --a, a--            dec
 */

/**
 * Когда определяются функции inc и dec для перегрузки операторов инкремента и декремента, компилятор автоматически
 * поддерживает ту же семантику пред- и постинкремента, что и для обычных числовых типов. Взгляните на следующий пример -
 * перегружающий оператор ++ для класса BigDecimal.
 */
operator fun BigDecimal.inc() = this + BigDecimal.ONE

fun testBigDecimalIncrement() {
    var bigDecimal = BigDecimal(10)
    println(++bigDecimal)
}
