package chapter6

/**
 * Работа с простыми типами, допускающими значение null
 */
data class Person7(
    val name: String,
    val age: Int? = null,
) {
    /**
     * Обратите внимание, что здесь применяются обычные правила работы со значением null. Нельзя просто взять и
     * сравнить два значения типа Int?, поскольку одно из них может оказаться null. Вместо этого вам нужно убедиться,
     * что оба значения не равны null, и после этого компилятор позволит работать с ними как обычно.
     */
    fun isOlderThan(other: Person7): Boolean? {
        if (age == null || other.age == null)
            return null
        return age > other.age
    }
}

/**
 * Обобщенные классы - это ещё одна ситуация, когда на сцену выходят оберточные типы. Если в качестве аргумента типа
 * указан простой тип, Kotlin будет использовать обертку для данного типа. Например, следующее объявление создаст список
 * значений типа Integer, даже если вы не указывали, что тип допускает значение null, и не использовали самого значения null:
 */
val listOfInts = listOf(1, 2, 3)

/**
 * Числовые преобразования
 */
val i = 1

//val l: Long = i        // ошибка - несоответствие типов
val l: Long = i.toLong()        // вместо этого нужно применить явное преобразование

/**
 * Функции преобразования определены для каждого простого типа (кроме Boolean): toByte(), toShort(), toChar() и т. д.
 * Функции поддерживают преобразование в обоих направлениях: расширение меньшего типа к большему, как Int.toLong(),
 * и усечение большего типа до меньшего, как Long.toInt().
 */

fun testTypeConversion() {
    val x = 1
    val list = listOf(1L, 2L, 3L)
//    x in list     // ошибка, т.к. Kotlin не поддерживает неявные преобразования
    /**
     *  можно сделать так, т.к. Kotlin требует явного преобразования типов
     */
    println(x.toLong() in list)
}

/**
 * Арифметические операторы перегружены для всех соответствующих числовых типов. Например, следующий код работает
 * правильно без каких-либо явных преобразований:
 */
fun printLong(l: Long) = println(l)

fun testPrintLong() {
    val b: Byte = 1         // значение константы получит корректный тип
    val l = b + 1L          // оператор "+" работает с аргументами типа Byte и Long
    printLong(42)       // компилятор интерпретирует 42 как значение типа Long
    /**
     * Стандартная библиотека Kotlin включает набор функций-расширений для преобразования строк в проcтые
     * типы (toInt,toByte,toBoolean и т.д.):
     */
    println("42".toInt())
}
