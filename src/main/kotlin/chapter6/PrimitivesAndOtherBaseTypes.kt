package chapter6

/**
 * Работа с простыми типами, допускающими значение null
 */
data class Person7(
    val name: String,
    val age: Int? = null,
) {
    /**
     * Обратите внимание, что здесь применяются обычные правила работы со значением null. Нельзя просто взять и
     * сравнить два значения типа Int?, поскольку одно из них может оказаться null. Вместо этого вам нужно убедиться,
     * что оба значения не равны null, и после этого компилятор позволит работать с ними как обычно.
     */
    fun isOlderThan(other: Person7): Boolean? {
        if (age == null || other.age == null)
            return null
        return age > other.age
    }
}

/**
 * Обобщенные классы - это ещё одна ситуация, когда на сцену выходят оберточные типы. Если в качестве аргумента типа
 * указан простой тип, Kotlin будет использовать обертку для данного типа. Например, следующее объявление создаст список
 * значений типа Integer, даже если вы не указывали, что тип допускает значение null, и не использовали самого значения null:
 */
val listOfInts = listOf(1, 2, 3)

/**
 * Числовые преобразования
 */
val i = 1

//val l: Long = i        // ошибка - несоответствие типов
val l: Long = i.toLong()        // вместо этого нужно применить явное преобразование

/**
 * Функции преобразования определены для каждого простого типа (кроме Boolean): toByte(), toShort(), toChar() и т. д.
 * Функции поддерживают преобразование в обоих направлениях: расширение меньшего типа к большему, как Int.toLong(),
 * и усечение большего типа до меньшего, как Long.toInt().
 */

fun testTypeConversion() {
    val x = 1
    val list = listOf(1L, 2L, 3L)
//    x in list     // ошибка, т.к. Kotlin не поддерживает неявные преобразования
    /**
     *  можно сделать так, т.к. Kotlin требует явного преобразования типов
     */
    println(x.toLong() in list)
}

/**
 * Арифметические операторы перегружены для всех соответствующих числовых типов. Например, следующий код работает
 * правильно без каких-либо явных преобразований:
 */
fun printLong(l: Long) = println(l)

fun testPrintLong() {
    val b: Byte = 1         // значение константы получит корректный тип
    val l = b + 1L          // оператор "+" работает с аргументами типа Byte и Long
    printLong(42)       // компилятор интерпретирует 42 как значение типа Long
    /**
     * Стандартная библиотека Kotlin включает набор функций-расширений для преобразования строк в проcтые
     * типы (toInt,toByte,toBoolean и т.д.):
     */
    println("42".toInt())
}

/**
 * Подобно тому, как тип Object является корнем иерархии классов в Java, тип Any - это супертип всех типов в Kotlin
 * (в том числе и для примитивных), не поддерживающих null.
 */

/**
 * Так же как в Java, присваивание примитивного значения переменной типа Any вызывает автоматическую упаковку значения:
 */
val answer: Any = 42        // значение 42 будет упаковано, поскольку тип Any является ссылочным

/**
 * Все классы в Kotlin имеют три метода: toString, equals и hashCode. Эти методы наследуются от класса Any.
 * Другие методы, объявленные в классе java.lang.Object (например, wait и notify), недоступны в классе Any, но их можно
 * вызвать, если вручную привести значение к типу java.lang.Object.
 */
fun testAnswerMethodsInvocation() {
    answer.hashCode()
    answer as Object
    answer.notify()
}

/**
 * Тип Unit играет в Kotlin ту же роль, что и void в Java. Он может использоваться в качестве типа возвращаемого
 * значения функции, которая не возвращает ничего интересного:
 */
fun f(): Unit {
    /*...*/
}

/**
 * Синтаксически это определение равноценно следующему, где отсутствует объявление типа тела функции:
 */
fun f1() {      // явное объявление типа опущено
    /*...*/
}

/**
 * В отличие от void, тип Unit - это полноценный тип, который может использоваться как аргумент типа. Существует только
 * один экземпляр данного типа - он тоже называется Unit и возвращается неявно. Это полезно при переопределении
 * функции с обобщенным параметром, чтобы заставить её возвращать значение типа Unit:
 */
interface Processor<T>{
    fun process(): T
}

/**
 * Сигнатура интерфейса требует, чтобы функция process возвращала значение, а поскольку тип Unit не имеет значения,
 * вернуть его из метода не проблема. Но вам не нужно явно писать инструкцию return в функции NoResultProcessor.process,
 * потому что return Unit неявно добавляется компилятором.
 */
class NoResultProcessor: Processor<Unit>{
    override fun process() {        // возвращает значение типа Unit, но в объявлении этого не указано
        // to do something          // не требуется писать инструкцию return
    }
}

/**
 * Для некоторых функций в Kotlin понятие возвращаемого значения просто не имеет смысла, поскольку они никогда не
 * возвращают управления. Например, во многих библиотеках для тестирования есть функция fail, которая генерирует
 * исключение с указанным сообщением и заставляет текущий тест завершиться неудачей. Функция с бесконечным циклом
 * также никогда не завершится.
 * При анализе кода, вызывающего такую функцию, полезно знать, что она не возвращает управления. Чтобы выразить это,
 * в Kotlin используется специальный тип возвращаемого значения Nothing:
 */
fun fail(message: String): Nothing {
    throw IllegalStateException(message)
}
/**
 * Тип Nothing не имеет значений, поэтому его имеет смысл использовать только в качестве типа возвращаемого значения
 * функции или аргумента типа для обозначения типа возвращаемого значения обобщенной функции. Во всех остальных случаях
 * объявление переменной, в которой нельзя сохранить значение, не имеет смысла.
 */

/**
 * Обратите внимание, что функции, возвращающие Nothing, могут использоваться справа от оператора «Элвис» для
 * проверки предусловий:
 */
val company: Company = Company("MyCompany", null)
val address = company.address ?: fail("No address")

fun testNothing(){
    println(address.city)
}
